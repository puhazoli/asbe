# AUTOGENERATED! DO NOT EDIT! File to edit: 01_core.ipynb (unless otherwise specified).

__all__ = ['RandomAcquisitionFunction', 'UncertaintyAcquisitionFunction', 'TypeSAcquistionFunction',
           'EMCMAcquisitionFunction', 'RandomAssignmentFunction', 'MajorityAssignmentFunction']

# Cell
import numpy as np
from .base import *
from modAL.models.base import BaseLearner
from sklearn.base import BaseEstimator, ClassifierMixin, RegressorMixin
from sklearn.linear_model import SGDRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from typing import Union, Optional, Callable
from copy import deepcopy
from pylift.eval import UpliftEval

# Cell
class RandomAcquisitionFunction(BaseAcquisitionFunction):
    def calculate_metrics(self, model, dataset):
        ixs = np.arange(dataset["X_pool"].shape[0])
        np.random.shuffle(ixs)
        return ixs

class UncertaintyAcquisitionFunction(BaseAcquisitionFunction):
    def calculate_metrics(self, model, dataset):
        preds = model.predict(dataset["X_pool"])
        if type(preds) is tuple:
            p, pred_var = preds[0], preds[1]
        try:
            if preds.shape[1] <= 1:
                raise Exception("Not possible to calculate uncertainty when dimensions <=1")
            pred_var = np.var(preds, axis = 1)
        except IndexError:
            raise Exception("Not possible to calculate uncertainty when dimensions <=1")
        return pred_var

class TypeSAcquistionFunction(BaseAcquisitionFunction):
    def calculate_metrics(self, model, dataset):
        preds = model.predict(dataset["X_pool"])
        if preds.shape[0] <= 1 or len(y1_preds.shape) <= 1:
            raise Exception("Type S error needs multiple values per prediction")
        prob_s = np.sum(preds > 0, axis=1)/preds.shape[1]
        prob_s_sel = np.where(prob_s > 0.5, 1-prob_s, prob_s) + .0001

class EMCMAcquisitionFunction(BaseAcquisitionFunction):
    def __init__(self, no_query = 1,
                 method = "top",
                 name = "emcm",
                 approx_model = SGDRegressor()):
        super().__init__(no_query, method, name)
        self.approx_model = approx_model

    def calculate_metrics(self, model, dataset):
        pass

# Cell
class RandomAssignmentFunction(BaseAssignmentFunction):
    def __init__(self, base_selection = 0, p = .5):
        super().__init__(base_selection)
        self.p = p

    def select_treatment(self, model, dataset, query_idx):
        return np.random.binomial(1, self.p, (query_idx.shape[0],))

class MajorityAssignmentFunction(BaseAssignmentFunction):
    def select_treatment(self, model, dataset, query_idx):
        if sum(dataset["t_training"]) >= dataset["t_training"].shape[0]/2:
            out = np.zeros((query_idx.shape[0],))
        else:
            out = np.ones((query_idx.shape[0],))
        return out